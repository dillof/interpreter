// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Parser class

class Parser: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case WORD                           =   1
      case TENS                           =   2
      case ONES                           =   3
      case HUNDRED                        =   4
      case THOUSAND                       =   5
      case MILLON                         =   6
      case DOT                            =   7
      case MINUS                          =   8
      case ADD                            =   9
      case TO                             =  10
      case MULTIPLY                       =  11
      case WITH                           =  12
      case SUBTRACT                       =  13
      case FROM                           =  14
      case DIVIDE                         =  15
      case BY                             =  16
      case VALUE                          =  17
      case OF                             =  18
      case AND                            =  19
      case SET                            =  20
      case CALL                           =  21
      case RETURN                         =  22
      case IF                             =  23
      case THEN                           =  24
      case DO                             =  25
      case DONE                           =  26
      case ELSE                           =  27
      case LESS                           =  28
      case THAN                           =  29
      case GREATER                        =  30
      case EQUAL                          =  31
      case IS                             =  32
      case NOT                            =  33
      case OR                             =  34
      case FUNCTION                       =  35
      case NAME                           =  36
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case function_definition            =  37
      case program                        =  38
      case unit_list                      =  39
      case unit                           =  40
      case statement                      =  41
      case name                           =  42
      case integer_tens                   =  43
      case integer_hundreds               =  44
      case integer_thousands              =  45
      case integer_millions               =  46
      case integer                        =  47
      case float                          =  48
      case number                         =  49
      case term                           =  50
      case expression                     =  51
      case function_call                  =  52
      case condition                      =  53
      case argument_list                  =  54
      case statement_list                 =  55
      case half_comparison                =  56
      case comparison                     =  57
      case name_list                      =  58
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 37) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 59) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = Token

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy5(Function)
        case yy11(ExpressionList)
        case yy16(Name)
        case yy19(UnitList)
        case yy20(Int)
        case yy21(Number)
        case yy38(NameList)
        case yy40(Expresssion)
        case yy41(HalfComparison)
        case yy45(Program)
        case yy63(Expression)
        case yy73(Unit)
        case yy114(DoubleAssembler)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy5(let value): return value as Any
            case .yy11(let value): return value as Any
            case .yy16(let value): return value as Any
            case .yy19(let value): return value as Any
            case .yy20(let value): return value as Any
            case .yy21(let value): return value as Any
            case .yy38(let value): return value as Any
            case .yy40(let value): return value as Any
            case .yy41(let value): return value as Any
            case .yy45(let value): return value as Any
            case .yy63(let value): return value as Any
            case .yy73(let value): return value as Any
            case .yy114(let value): return value as Any
            }
        }
    }

    typealias CitronResult = UnitList

    // Counts

    let yyNumberOfSymbols: Int = 59
    let yyNumberOfStates: Int = 74

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  (42, .SH(73)), (43, .RD(13)), (44, .SH(70)), ( 1, .SR( 6)), (46, .RD(18)),
/*   5 */  (47, .SH(68)), (48, .SH(67)), (49, .RD(26)), (50, .RD(27)), (51, .SH(57)),
/*  10 */  (41, .RD(44)), (53, .SH(40)), (42, .SH(73)), (43, .RD(13)), (44, .SH(70)),
/*  15 */  (57, .RD(50)), (46, .RD(18)), (47, .SH(68)), (48, .SH(67)), (49, .RD(26)),
/*  20 */  (50, .RD(27)), (51, .SH(49)), (56, .RD(48)), (53, .SH(43)), (42, .SH(73)),
/*  25 */  (43, .RD(13)), (44, .SH(70)), (57, .RD(50)), (46, .RD(18)), (47, .SH(68)),
/*  30 */  (48, .SH(67)), (49, .RD(26)), (50, .RD(27)), (51, .SH(51)), (56, .RD(49)),
/*  35 */  (53, .SH(43)), (42, .SH(73)), (43, .RD(13)), (44, .SH(70)), (57, .RD(50)),
/*  40 */  (46, .RD(18)), (47, .SH(68)), (48, .SH(67)), (49, .RD(26)), (50, .RD(27)),
/*  45 */  (51, .SH(53)), (43, .RD(11)), (53, .SH(43)), (42, .SH(73)), (43, .RD(13)),
/*  50 */  (44, .SH(70)), (57, .RD(50)), (46, .RD(18)), (47, .SH(68)), (48, .SH(67)),
/*  55 */  (49, .RD(26)), (50, .RD(27)), (51, .SH(55)), (36, .SR(55)), (53, .SH(43)),
/*  60 */  (42, .SH(73)), (43, .RD(13)), (44, .SH(70)), (57, .RD(50)), (46, .RD(18)),
/*  65 */  (47, .SH(68)), (48, .SH(67)), (49, .RD(26)), (50, .RD(27)), (51, .SH(57)),
/*  70 */  (58, .SH(41)), (53, .SH(58)), (42, .SH(73)), (43, .RD(13)), (44, .SH(70)),
/*  75 */  (57, .RD(50)), (46, .RD(18)), (47, .SH(68)), (48, .SH(67)), (49, .RD(26)),
/*  80 */  (50, .RD(27)), (51, .SH(57)), (41, .RD(43)), (53, .SH(42)), (42, .SH(73)),
/*  85 */  (43, .RD(13)), (44, .SH(70)), (57, .RD(50)), (46, .RD(18)), (47, .SH(68)),
/*  90 */  (48, .SH(67)), (49, .RD(26)), (50, .RD(27)), (51, .SH(50)), (37, .RD( 5)),
/*  95 */  (53, .SH(43)), (55, .SH(30)), (40, .RD( 3)), (41, .RD( 4)), (57, .RD(50)),
/* 100 */  (42, .SH(39)), ( 1, .SR( 6)), ( 2, .SH(72)), ( 3, .SH(71)), (20, .SH(38)),
/* 105 */  (21, .SH(27)), (22, .SH( 2)), (23, .SH( 1)), ( 8, .SH(19)), ( 9, .SH(18)),
/* 110 */  (26, .SR(54)), (11, .SH(16)), (32, .RD(33)), (13, .SH(14)), (34, .SH( 6)),
/* 115 */  (15, .SH(12)), (42, .SH(45)), (17, .SH(60)), (42, .SH(73)), (43, .RD(13)),
/* 120 */  (44, .SH(70)), (25, .SH(24)), (46, .RD(18)), (47, .SH(68)), (48, .SH(67)),
/* 125 */  (49, .RD(26)), (50, .RD(36)), (42, .SH(73)), (43, .RD(13)), (44, .SH(70)),
/* 130 */  (54, .SH(59)), (46, .RD(18)), (47, .SH(68)), (48, .SH(67)), (49, .RD(26)),
/* 135 */  (50, .RD(37)), (42, .SH(73)), (43, .RD(13)), (44, .SH(70)), ( 1, .SR( 7)),
/* 140 */  (46, .RD(18)), (47, .SH(68)), (48, .SH(67)), (49, .RD(26)), (50, .RD(31)),
/* 145 */  (42, .SH(73)), (43, .RD(13)), (44, .SH(70)), (10, .SH( 8)), (46, .RD(18)),
/* 150 */  (47, .SH(68)), (48, .SH(67)), (49, .RD(26)), (50, .SH(61)), (42, .SH(73)),
/* 155 */  (43, .RD(13)), (44, .SH(70)), (25, .SH(25)), (46, .RD(18)), (47, .SH(68)),
/* 160 */  (48, .SH(67)), (49, .RD(26)), (50, .RD(30)), (42, .SH(73)), (43, .RD(13)),
/* 165 */  (44, .SH(70)), (32, .SH(33)), (46, .RD(18)), (47, .SH(68)), (48, .SH(67)),
/* 170 */  (49, .RD(26)), (50, .SH(62)), (42, .SH(73)), (43, .RD(13)), (44, .SH(70)),
/* 175 */  (10, .SH( 3)), (46, .RD(18)), (47, .SH(68)), (48, .SH(67)), (49, .RD(26)),
/* 180 */  (50, .RD(29)), (42, .SH(73)), (43, .RD(13)), (44, .SH(70)), (29, .SH( 4)),
/* 185 */  (46, .RD(18)), (47, .SH(68)), (48, .SH(67)), (49, .RD(26)), (50, .SH(63)),
/* 190 */  (42, .SH(73)), (43, .RD(13)), (44, .SH(70)), ( 0, .RD( 0)), (46, .RD(18)),
/* 195 */  (47, .SH(68)), (48, .SH(67)), (49, .RD(26)), (50, .RD(28)), (42, .SH(73)),
/* 200 */  (43, .RD(13)), (44, .SH(70)), ( 0, .RD( 1)), (46, .RD(18)), (47, .SH(68)),
/* 205 */  (48, .SH(67)), (49, .RD(26)), (50, .SH(64)), (37, .RD( 5)), (38, .ACCEPT),  
/* 210 */  (39, .SH(20)), (40, .RD( 2)), (41, .RD( 4)), (20, .SH(38)), (21, .SH(27)),
/* 215 */  (22, .SH( 2)), (23, .SH( 1)), (20, .SH(38)), (21, .SH(27)), (22, .SH( 2)),
/* 220 */  (23, .SH( 1)), (29, .SH( 5)), (20, .SH(38)), (21, .SH(27)), (22, .SH( 2)),
/* 225 */  (23, .SH( 1)), (43, .RD(13)), (44, .SH(70)), (35, .SH(37)), (46, .RD(18)),
/* 230 */  (47, .SH(66)), (48, .SH(65)), (20, .SH(38)), (21, .SH(27)), (22, .SH( 2)),
/* 235 */  (23, .SH( 1)), (36, .SR(56)), (35, .SH(37)), (26, .SR(53)), (32, .RD(33)),
/* 240 */  ( 1, .SR( 6)), ( 2, .SH(72)), ( 3, .SH(71)), (20, .SH(38)), (21, .SH(27)),
/* 245 */  (22, .SH( 2)), (23, .SH( 1)), ( 8, .SH(19)), (19, .SH(10)), (26, .SR(41)),
/* 250 */  (27, .SH(47)), (20, .SH(38)), (21, .SH(27)), (22, .SH( 2)), (23, .SH( 1)),
/* 255 */  (18, .SH(28)), (28, .SH(56)), (26, .SR(42)), (30, .SH(54)), (31, .SH(52)),
/* 260 */  ( 1, .SR( 7)), (33, .SH(34)), (43, .RD(13)), (44, .SH(69)), (45, .RD(16)),
/* 265 */  (19, .SH( 7)), (28, .SH(56)), (41, .RD(43)), (30, .SH(54)), (31, .SH(52)),
/* 270 */  (24, .SH(48)), (12, .SH(36)), ( 2, .SH(72)), ( 3, .SH(71)), (41, .RD(43)),
/* 275 */  (41, .RD(43)), ( 2, .SH(72)), ( 3, .SR(10)), (43, .RD(13)), (44, .RD(14)),
/* 280 */  (34, .SH( 6)), (55, .SH(31)), (19, .SH( 7)), (42, .SH(44)), (25, .SH(22)),
/* 285 */  (42, .SH(44)), (19, .SH(46)), ( 1, .SR( 7)), (55, .SH(32)), (55, .SH(29)),
/* 290 */  (14, .SH(13)), (16, .SH(11)), (25, .SH(23)), (52, .RD(39)), (12, .SH(15)),
/* 295 */  (52, .RD(32)), ( 3, .SR(20)), (34, .SH( 6)), (12, .SH( 9)), (10, .SH(17)),
/* 300 */  ( 5, .SH(26)), ( 7, .SR(19)), ( 6, .SH(21)), ( 4, .SH(35)), ( 3, .SR( 8)),
/* 305 */  ( 1, .SR( 7)),
    ]

    let yyShiftUseDefault: Int = 306
    let yyShiftOffsetMin: Int = 0
    let yyShiftOffsetMax: Int = 304
    let yyShiftOffset: [Int] = [
        /*     0 */   193,  100,  100,  100,  100,  100,  100,  100,  100,  239,
        /*    10 */   239,  239,  239,  239,  239,  239,  239,  239,  239,  270,
        /*    20 */   202,  270,  197,  197,  197,  197,  270,    2,    2,  223,
        /*    30 */    84,  212,  231,  228,  238,  274,   22,    2,    2,  259,
        /*    40 */   246,  267,   80,  263,  286,  138,  200,   96,  132,  134,
        /*    50 */   134,  134,  165,  134,  155,  134,  192,  134,  207,  229,
        /*    60 */   237,  275,  276,  282,  289,  293,  294,  293,  294,  295,
        /*    70 */   296,  299,  301,  304,
    ]

    let yyReduceUseDefault: Int = -43
    let yyReduceOffsetMin: Int =   -42
    let yyReduceOffsetMax: Int =   243
    let yyReduceOffset: [Int] = [
        /*     0 */   171,  -42,  -30,  -18,   -6,    6,   18,   30,   42,   76,
        /*    10 */    85,   94,  103,  112,  121,  130,  139,  148,  157,  183,
        /*    20 */    57,  219,   41,  226,  233,  234,  235,  241,  243,  -31,
        /*    30 */   -31,  -31,  -31,  -34,  -22,    3,   12,   58,   74,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*     5 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    10 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    15 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    20 */  .ERROR , .RD(17), .ERROR , .ERROR , .ERROR ,
  /*    25 */  .ERROR , .RD(15), .ERROR , .ERROR , .ERROR ,
  /*    30 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    35 */  .RD(12), .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    40 */  .RD(33), .ERROR , .RD(51), .RD(33), .RD(34),
  /*    45 */  .ERROR , .ERROR , .ERROR , .ERROR , .RD(40),
  /*    50 */  .RD(38), .RD(47), .ERROR , .RD(46), .ERROR ,
  /*    55 */  .RD(45), .ERROR , .ERROR , .RD(52), .RD(35),
  /*    60 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    65 */  .RD(24), .RD(22), .RD(23), .RD(21), .ERROR ,
  /*    70 */  .ERROR , .RD(10), .RD( 9), .RD(25),
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 38, nrhs: 0),
        (lhs: 38, nrhs: 1),
        (lhs: 39, nrhs: 1),
        (lhs: 39, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 1),
        (lhs: 42, nrhs: 1),
        (lhs: 42, nrhs: 2),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 1),
        (lhs: 44, nrhs: 3),
        (lhs: 44, nrhs: 2),
        (lhs: 44, nrhs: 1),
        (lhs: 45, nrhs: 3),
        (lhs: 45, nrhs: 2),
        (lhs: 46, nrhs: 3),
        (lhs: 46, nrhs: 2),
        (lhs: 47, nrhs: 1),
        (lhs: 48, nrhs: 2),
        (lhs: 48, nrhs: 2),
        (lhs: 49, nrhs: 1),
        (lhs: 49, nrhs: 2),
        (lhs: 49, nrhs: 1),
        (lhs: 49, nrhs: 2),
        (lhs: 50, nrhs: 1),
        (lhs: 50, nrhs: 1),
        (lhs: 51, nrhs: 1),
        (lhs: 51, nrhs: 4),
        (lhs: 51, nrhs: 4),
        (lhs: 51, nrhs: 4),
        (lhs: 51, nrhs: 4),
        (lhs: 51, nrhs: 3),
        (lhs: 51, nrhs: 1),
        (lhs: 52, nrhs: 1),
        (lhs: 52, nrhs: 3),
        (lhs: 54, nrhs: 1),
        (lhs: 54, nrhs: 3),
        (lhs: 41, nrhs: 4),
        (lhs: 41, nrhs: 2),
        (lhs: 41, nrhs: 2),
        (lhs: 41, nrhs: 6),
        (lhs: 41, nrhs: 9),
        (lhs: 55, nrhs: 1),
        (lhs: 55, nrhs: 2),
        (lhs: 56, nrhs: 3),
        (lhs: 56, nrhs: 3),
        (lhs: 56, nrhs: 3),
        (lhs: 57, nrhs: 3),
        (lhs: 57, nrhs: 4),
        (lhs: 53, nrhs: 1),
        (lhs: 53, nrhs: 3),
        (lhs: 53, nrhs: 3),
        (lhs: 37, nrhs: 7),
        (lhs: 37, nrhs: 5),
        (lhs: 58, nrhs: 1),
        (lhs: 58, nrhs: 3),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "WORD",
    /*  2 */ "TENS",
    /*  3 */ "ONES",
    /*  4 */ "HUNDRED",
    /*  5 */ "THOUSAND",
    /*  6 */ "MILLON",
    /*  7 */ "DOT",
    /*  8 */ "MINUS",
    /*  9 */ "ADD",
    /* 10 */ "TO",
    /* 11 */ "MULTIPLY",
    /* 12 */ "WITH",
    /* 13 */ "SUBTRACT",
    /* 14 */ "FROM",
    /* 15 */ "DIVIDE",
    /* 16 */ "BY",
    /* 17 */ "VALUE",
    /* 18 */ "OF",
    /* 19 */ "AND",
    /* 20 */ "SET",
    /* 21 */ "CALL",
    /* 22 */ "RETURN",
    /* 23 */ "IF",
    /* 24 */ "THEN",
    /* 25 */ "DO",
    /* 26 */ "DONE",
    /* 27 */ "ELSE",
    /* 28 */ "LESS",
    /* 29 */ "THAN",
    /* 30 */ "GREATER",
    /* 31 */ "EQUAL",
    /* 32 */ "IS",
    /* 33 */ "NOT",
    /* 34 */ "OR",
    /* 35 */ "FUNCTION",
    /* 36 */ "NAME",
    /* 37 */ "function_definition",
    /* 38 */ "program",
    /* 39 */ "unit_list",
    /* 40 */ "unit",
    /* 41 */ "statement",
    /* 42 */ "name",
    /* 43 */ "integer_tens",
    /* 44 */ "integer_hundreds",
    /* 45 */ "integer_thousands",
    /* 46 */ "integer_millions",
    /* 47 */ "integer",
    /* 48 */ "float",
    /* 49 */ "number",
    /* 50 */ "term",
    /* 51 */ "expression",
    /* 52 */ "function_call",
    /* 53 */ "condition",
    /* 54 */ "argument_list",
    /* 55 */ "statement_list",
    /* 56 */ "half_comparison",
    /* 57 */ "comparison",
    /* 58 */ "name_list",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "program ::=",
        /*   1 */ "program ::= unit_list(p)",
        /*   2 */ "unit_list ::= unit(u)",
        /*   3 */ "unit_list ::= unit_list(p) unit(u)",
        /*   4 */ "unit ::= statement(s)",
        /*   5 */ "unit ::= function_definition(f)",
        /*   6 */ "name ::= WORD(w)",
        /*   7 */ "name ::= name(n) WORD(w)",
        /*   8 */ "integer_tens ::= TENS(t) ONES(o)",
        /*   9 */ "integer_tens ::= TENS(t)",
        /*  10 */ "integer_tens ::= ONES(o)",
        /*  11 */ "integer_hundreds ::= ONES(o) HUNDRED integer_tens(i)",
        /*  12 */ "integer_hundreds ::= ONES(o) HUNDRED",
        /*  13 */ "integer_hundreds ::= integer_tens(i)",
        /*  14 */ "integer_thousands ::= integer_hundreds(t) THOUSAND integer_hundreds(i)",
        /*  15 */ "integer_thousands ::= integer_hundreds(t) THOUSAND",
        /*  16 */ "integer_millions ::= integer_hundreds(m) MILLON integer_thousands(i)",
        /*  17 */ "integer_millions ::= integer_hundreds MILLON",
        /*  18 */ "integer ::= integer_millions(i)",
        /*  19 */ "float ::= integer(i) DOT",
        /*  20 */ "float ::= float(f) ONES(d)",
        /*  21 */ "number ::= integer(i)",
        /*  22 */ "number ::= MINUS integer(i)",
        /*  23 */ "number ::= float(f)",
        /*  24 */ "number ::= MINUS float(f)",
        /*  25 */ "term ::= name(n)",
        /*  26 */ "term ::= number(n)",
        /*  27 */ "expression ::= term(t)",
        /*  28 */ "expression ::= ADD term(l) TO term(r)",
        /*  29 */ "expression ::= MULTIPLY term(l) WITH term(r)",
        /*  30 */ "expression ::= SUBTRACT term(l) FROM term(r)",
        /*  31 */ "expression ::= DIVIDE term(l) BY term(r)",
        /*  32 */ "expression ::= VALUE OF function_call(f)",
        /*  33 */ "expression ::= condition(c)",
        /*  34 */ "function_call ::= name(n)",
        /*  35 */ "function_call ::= name(n) WITH argument_list(a)",
        /*  36 */ "argument_list ::= term(t)",
        /*  37 */ "argument_list ::= argument_list(l) AND term(t)",
        /*  38 */ "statement ::= SET name(n) TO expression(e)",
        /*  39 */ "statement ::= CALL function_call(f)",
        /*  40 */ "statement ::= RETURN expression(e)",
        /*  41 */ "statement ::= IF condition(c) THEN DO statement_list(t) DONE",
        /*  42 */ "statement ::= IF condition(c) THEN DO statement_list(t) ELSE DO statement_list(e) DONE",
        /*  43 */ "statement_list ::= statement(s)",
        /*  44 */ "statement_list ::= statement_list(l) statement(s)",
        /*  45 */ "half_comparison ::= LESS THAN expression(e)",
        /*  46 */ "half_comparison ::= GREATER THAN expression(e)",
        /*  47 */ "half_comparison ::= EQUAL TO expression(e)",
        /*  48 */ "comparison ::= expression(l) IS half_comparison(r)",
        /*  49 */ "comparison ::= expression(l) IS NOT half_comparison(r)",
        /*  50 */ "condition ::= comparison(c)",
        /*  51 */ "condition ::= condition(l) AND condition(r)",
        /*  52 */ "condition ::= condition(l) OR condition(r)",
        /*  53 */ "function_definition ::= FUNCTION name WITH name_list DO statement_list DONE",
        /*  54 */ "function_definition ::= FUNCTION name DO statement_list DONE",
        /*  55 */ "name_list ::= NAME(n)",
        /*  56 */ "name_list ::= name_list(l) AND NAME(n)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* program ::= */
            func codeBlockForRule00() throws -> UnitList { return UnitList()  }
            return .yy19(try codeBlockForRule00())
        case 1: /* program ::= unit_list(p) */
            func codeBlockForRule01(p: Program) throws -> UnitList { return p  }
            if case .yy45(let p) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule01(p: p))
            }
        case 2: /* unit_list ::= unit(u) */
            func codeBlockForRule02(u: Unit) throws -> Program { return UnitList(u)  }
            if case .yy73(let u) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy45(try codeBlockForRule02(u: u))
            }
        case 3: /* unit_list ::= unit_list(p) unit(u) */
            func codeBlockForRule03(p: Program, u: Unit) throws -> Program { p.append(u); return p  }
            if case .yy45(let p) = yySymbolOnStack(distanceFromTop: 1),
               case .yy73(let u) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy45(try codeBlockForRule03(p: p, u: u))
            }
        case 4: /* unit ::= statement(s) */
            func codeBlockForRule04(s: Unit) throws -> Unit { return s  }
            if case .yy73(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy73(try codeBlockForRule04(s: s))
            }
        case 5: /* unit ::= function_definition(f) */
            func codeBlockForRule05(f: Function) throws -> Unit { return f  }
            if case .yy5(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy73(try codeBlockForRule05(f: f))
            }
        case 6: /* name ::= WORD(w) */
            func codeBlockForRule06(w: Token) throws -> Name { return Name(w)  }
            if case .yy0(let w) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy16(try codeBlockForRule06(w: w))
            }
        case 7: /* name ::= name(n) WORD(w) */
            func codeBlockForRule07(n: Name, w: Token) throws -> Name { return Name(n, w)  }
            if case .yy16(let n) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let w) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy16(try codeBlockForRule07(n: n, w: w))
            }
        case 8: /* integer_tens ::= TENS(t) ONES(o) */
            func codeBlockForRule08(t: Token, o: Token) throws -> Int { return int_value(t) + int_value(o)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let o) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule08(t: t, o: o))
            }
        case 9: /* integer_tens ::= TENS(t) */
            func codeBlockForRule09(t: Token) throws -> Int { return int_value(t)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule09(t: t))
            }
        case 10: /* integer_tens ::= ONES(o) */
            func codeBlockForRule10(o: Token) throws -> Int { return int_value(o)  }
            if case .yy0(let o) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule10(o: o))
            }
        case 11: /* integer_hundreds ::= ONES(o) HUNDRED integer_tens(i) */
            func codeBlockForRule11(o: Token, i: Int) throws -> Int { return int_value(o) * 100 + i  }
            if case .yy0(let o) = yySymbolOnStack(distanceFromTop: 2),
               case .yy20(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule11(o: o, i: i))
            }
        case 12: /* integer_hundreds ::= ONES(o) HUNDRED */
            func codeBlockForRule12(o: Token) throws -> Int { return int_value(o) * 100  }
            if case .yy0(let o) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy20(try codeBlockForRule12(o: o))
            }
        case 13: /* integer_hundreds ::= integer_tens(i) */
            func codeBlockForRule13(i: Int) throws -> Int { return i  }
            if case .yy20(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule13(i: i))
            }
        case 14: /* integer_thousands ::= integer_hundreds(t) THOUSAND integer_hundreds(i) */
            func codeBlockForRule14(t: Int, i: Int) throws -> Int { return t * 1000 + i  }
            if case .yy20(let t) = yySymbolOnStack(distanceFromTop: 2),
               case .yy20(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule14(t: t, i: i))
            }
        case 15: /* integer_thousands ::= integer_hundreds(t) THOUSAND */
            func codeBlockForRule15(t: Int) throws -> Int { return t * 1000  }
            if case .yy20(let t) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy20(try codeBlockForRule15(t: t))
            }
        case 16: /* integer_millions ::= integer_hundreds(m) MILLON integer_thousands(i) */
            func codeBlockForRule16(m: Int, i: Int) throws -> Int { return m * 1000000 + i  }
            if case .yy20(let m) = yySymbolOnStack(distanceFromTop: 2),
               case .yy20(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule16(m: m, i: i))
            }
        case 17: /* integer_millions ::= integer_hundreds MILLON */
            func codeBlockForRule17() throws -> Int { return m * 1000000  }
            return .yy20(try codeBlockForRule17())
        case 18: /* integer ::= integer_millions(i) */
            func codeBlockForRule18(i: Int) throws -> Int { return i  }
            if case .yy20(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy20(try codeBlockForRule18(i: i))
            }
        case 19: /* float ::= integer(i) DOT */
            func codeBlockForRule19(i: Int) throws -> DoubleAssembler { return DoubleAssembler(i)  }
            if case .yy20(let i) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy114(try codeBlockForRule19(i: i))
            }
        case 20: /* float ::= float(f) ONES(d) */
            func codeBlockForRule20(f: DoubleAssembler, d: Token) throws -> DoubleAssembler { f.append(d); return f  }
            if case .yy114(let f) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy114(try codeBlockForRule20(f: f, d: d))
            }
        case 21: /* number ::= integer(i) */
            func codeBlockForRule21(i: Int) throws -> Number { return Number(i)  }
            if case .yy20(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy21(try codeBlockForRule21(i: i))
            }
        case 22: /* number ::= MINUS integer(i) */
            func codeBlockForRule22(i: Int) throws -> Number { return Number(-i)  }
            if case .yy20(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy21(try codeBlockForRule22(i: i))
            }
        case 23: /* number ::= float(f) */
            func codeBlockForRule23(f: DoubleAssembler) throws -> Number { return Number(f.value)  }
            if case .yy114(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy21(try codeBlockForRule23(f: f))
            }
        case 24: /* number ::= MINUS float(f) */
            func codeBlockForRule24(f: DoubleAssembler) throws -> Number { return Number(-f.value)  }
            if case .yy114(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy21(try codeBlockForRule24(f: f))
            }
        case 25: /* term ::= name(n) */
            func codeBlockForRule25(n: Name) throws -> Expression { return .Name(n)  }
            if case .yy16(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule25(n: n))
            }
        case 26: /* term ::= number(n) */
            func codeBlockForRule26(n: Number) throws -> Expression { return .Number(n)  }
            if case .yy21(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule26(n: n))
            }
        case 27: /* expression ::= term(t) */
            func codeBlockForRule27(t: Expression) throws -> Expression { return t  }
            if case .yy63(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule27(t: t))
            }
        case 28: /* expression ::= ADD term(l) TO term(r) */
            func codeBlockForRule28(l: Expression, r: Expression) throws -> Expression { return .Add(l, r)  }
            if case .yy63(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy63(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule28(l: l, r: r))
            }
        case 29: /* expression ::= MULTIPLY term(l) WITH term(r) */
            func codeBlockForRule29(l: Expression, r: Expression) throws -> Expression { return .Multiply(l, r)  }
            if case .yy63(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy63(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule29(l: l, r: r))
            }
        case 30: /* expression ::= SUBTRACT term(l) FROM term(r) */
            func codeBlockForRule30(l: Expression, r: Expression) throws -> Expression { return .Subtract(l, r)  }
            if case .yy63(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy63(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule30(l: l, r: r))
            }
        case 31: /* expression ::= DIVIDE term(l) BY term(r) */
            func codeBlockForRule31(l: Expression, r: Expression) throws -> Expression { return .Divide(l, r)  }
            if case .yy63(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy63(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule31(l: l, r: r))
            }
        case 32: /* expression ::= VALUE OF function_call(f) */
            func codeBlockForRule32(f: Expression) throws -> Expression { return f  }
            if case .yy63(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule32(f: f))
            }
        case 33: /* expression ::= condition(c) */
            func codeBlockForRule33(c: Expresssion) throws -> Expression { return c  }
            if case .yy40(let c) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule33(c: c))
            }
        case 34: /* function_call ::= name(n) */
            func codeBlockForRule34(n: Name) throws -> Expression { return .FunctionCall(n, ExpressionList())  }
            if case .yy16(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule34(n: n))
            }
        case 35: /* function_call ::= name(n) WITH argument_list(a) */
            func codeBlockForRule35(n: Name, a: ExpressionList) throws -> Expression { return .FunctionCall(n, a) }
            if case .yy16(let n) = yySymbolOnStack(distanceFromTop: 2),
               case .yy11(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy63(try codeBlockForRule35(n: n, a: a))
            }
        case 36: /* argument_list ::= term(t) */
            func codeBlockForRule36(t: Expression) throws -> ExpressionList { return ExpressionList(t)  }
            if case .yy63(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy11(try codeBlockForRule36(t: t))
            }
        case 37: /* argument_list ::= argument_list(l) AND term(t) */
            func codeBlockForRule37(l: ExpressionList, t: Expression) throws -> ExpressionList { l.append(t); return l  }
            if case .yy11(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy63(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy11(try codeBlockForRule37(l: l, t: t))
            }
        case 38: /* statement ::= SET name(n) TO expression(e) */
            func codeBlockForRule38(n: Name, e: Expression) throws -> Unit { return .Set(n, e) }
            if case .yy16(let n) = yySymbolOnStack(distanceFromTop: 2),
               case .yy63(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy73(try codeBlockForRule38(n: n, e: e))
            }
        case 39: /* statement ::= CALL function_call(f) */
            func codeBlockForRule39(f: Expression) throws -> Unit { return .FunctionCall(f)  }
            if case .yy63(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy73(try codeBlockForRule39(f: f))
            }
        case 40: /* statement ::= RETURN expression(e) */
            func codeBlockForRule40(e: Expression) throws -> Unit { return .Return(e)  }
            if case .yy63(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy73(try codeBlockForRule40(e: e))
            }
        case 41: /* statement ::= IF condition(c) THEN DO statement_list(t) DONE */
            func codeBlockForRule41(c: Expresssion, t: UnitList) throws -> Unit { return .If(c, t, UnitList())  }
            if case .yy40(let c) = yySymbolOnStack(distanceFromTop: 4),
               case .yy19(let t) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy73(try codeBlockForRule41(c: c, t: t))
            }
        case 42: /* statement ::= IF condition(c) THEN DO statement_list(t) ELSE DO statement_list(e) DONE */
            func codeBlockForRule42(c: Expresssion, t: UnitList, e: UnitList) throws -> Unit { return .If(c, t, e)  }
            if case .yy40(let c) = yySymbolOnStack(distanceFromTop: 7),
               case .yy19(let t) = yySymbolOnStack(distanceFromTop: 4),
               case .yy19(let e) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy73(try codeBlockForRule42(c: c, t: t, e: e))
            }
        case 43: /* statement_list ::= statement(s) */
            func codeBlockForRule43(s: Unit) throws -> UnitList { return UnitList(s)  }
            if case .yy73(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule43(s: s))
            }
        case 44: /* statement_list ::= statement_list(l) statement(s) */
            func codeBlockForRule44(l: UnitList, s: Unit) throws -> UnitList { l.append(s); return l  }
            if case .yy19(let l) = yySymbolOnStack(distanceFromTop: 1),
               case .yy73(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule44(l: l, s: s))
            }
        case 45: /* half_comparison ::= LESS THAN expression(e) */
            func codeBlockForRule45(e: Expression) throws -> HalfComparison { return .Less(e)  }
            if case .yy63(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy41(try codeBlockForRule45(e: e))
            }
        case 46: /* half_comparison ::= GREATER THAN expression(e) */
            func codeBlockForRule46(e: Expression) throws -> HalfComparison { return .Greater(e)  }
            if case .yy63(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy41(try codeBlockForRule46(e: e))
            }
        case 47: /* half_comparison ::= EQUAL TO expression(e) */
            func codeBlockForRule47(e: Expression) throws -> HalfComparison { return .Equal(e)  }
            if case .yy63(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy41(try codeBlockForRule47(e: e))
            }
        case 48: /* comparison ::= expression(l) IS half_comparison(r) */
            func codeBlockForRule48(l: Expression, r: HalfComparison) throws -> Expresssion { return Expression(l, r)  }
            if case .yy63(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy41(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule48(l: l, r: r))
            }
        case 49: /* comparison ::= expression(l) IS NOT half_comparison(r) */
            func codeBlockForRule49(l: Expression, r: HalfComparison) throws -> Expresssion { return Expression(l, r)  }
            if case .yy63(let l) = yySymbolOnStack(distanceFromTop: 3),
               case .yy41(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule49(l: l, r: r))
            }
        case 50: /* condition ::= comparison(c) */
            func codeBlockForRule50(c: Expresssion) throws -> Expresssion { return c  }
            if case .yy40(let c) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule50(c: c))
            }
        case 51: /* condition ::= condition(l) AND condition(r) */
            func codeBlockForRule51(l: Expresssion, r: Expresssion) throws -> Expresssion { return .And(l, r)  }
            if case .yy40(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy40(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule51(l: l, r: r))
            }
        case 52: /* condition ::= condition(l) OR condition(r) */
            func codeBlockForRule52(l: Expresssion, r: Expresssion) throws -> Expresssion { return .Or(l, r)  }
            if case .yy40(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy40(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule52(l: l, r: r))
            }
        case 53: /* function_definition ::= FUNCTION name WITH name_list DO statement_list DONE */
            func codeBlockForRule53() throws -> Function { return Unit() /* TODO */  }
            return .yy5(try codeBlockForRule53())
        case 54: /* function_definition ::= FUNCTION name DO statement_list DONE */
            func codeBlockForRule54() throws -> Function { return Unit() */ TODO */  }
            return .yy5(try codeBlockForRule54())
        case 55: /* name_list ::= NAME(n) */
            func codeBlockForRule55(n: Token) throws -> NameList { return NameList(n)  }
            if case .yy0(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy38(try codeBlockForRule55(n: n))
            }
        case 56: /* name_list ::= name_list(l) AND NAME(n) */
            func codeBlockForRule56(l: NameList, n: Token) throws -> NameList { l.append(n); return l  }
            if case .yy38(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy38(try codeBlockForRule56(l: l, n: n))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy19(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _ParserCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [:]
    let yyCanErrorCapture: Bool = false
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [:]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = []

    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = []

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        fatalError("This parser was not generated with error capturing information")
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        fatalError("This parser was not generated with error capturing information")
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 38
    let yyEndStateNumber: CitronStateNumber = 0

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _ParserCitronErrorCaptureDelegate : class {
    func shouldSaveErrorForCapturing(error: Error) -> Bool
}

extension _ParserCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension Parser.CitronSymbolCode {
    static func == (a: Parser.CitronSymbolCode, b: Parser.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: Parser.CitronTokenCode, b: Parser.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: Parser.CitronSymbolCode, b: Parser.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: Parser.CitronNonTerminalCode, b: Parser.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension Parser.CitronSymbolCode {
    static func ~= (pattern: Parser.CitronTokenCode, value: Parser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: Parser.CitronNonTerminalCode, value: Parser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
